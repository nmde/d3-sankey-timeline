/// <reference types="jest-extended" />
import SankeyTimeline from '../src';

test('main', () => {
  const timeline = new SankeyTimeline();
  const v0 = timeline.addNode('v0', 0, 2);
  const v1 = timeline.addNode('v1', 2, 4);
  const v2 = timeline.addNode('v2', 4, 8);
  const v3 = timeline.addNode('v3', 3, 5);
  const v4 = timeline.addNode('v4', 6, 12);
  const v5 = timeline.addNode('v5', 11, 13);
  const a = timeline.addLink(v0, v1, 1);
  const b = timeline.addLink(v1, v2, 10);
  const c = timeline.addLink(v1, v3, 30);
  const d = timeline.addLink(v2, v4, 4);
  const e = timeline.addLink(v3, v2, 1);
  const f = timeline.addLink(v4, v0, 12);
  const g = timeline.addLink(v2, v5, 3);
  const h = timeline.addLink(v5, v5, 2);
  timeline.setRange([10, 190]);
  expect(a.isCircular).toBe(false);
  expect(b.isCircular).toBe(false);
  expect(c.isCircular).toBe(false);
  expect(d.isCircular).toBe(false);
  expect(e.isCircular).toBe(false);
  expect(f.isCircular).toBe(true);
  expect(g.isCircular).toBe(false);
  expect(h.isCircular).toBe(true);
  expect(v0.size).toBe(12);
  expect(v1.size).toBe(40);
  expect(v2.size).toBe(11);
  expect(v3.size).toBe(30);
  expect(v4.size).toBe(12);
  expect(v5.size).toBe(5);
  expect(v0.partOfCircuit).toBe(true);
  expect(v1.partOfCircuit).toBe(false);
  expect(v2.partOfCircuit).toBe(false);
  expect(v3.partOfCircuit).toBe(false);
  expect(v4.partOfCircuit).toBe(true);
  expect(v5.partOfCircuit).toBe(true);
  expect(timeline.minTime).toBe(0);
  expect(timeline.maxTime).toBe(13);
  expect(v0.x).toBeCloseTo(10);
  expect(v1.x).toBeCloseTo(37.692);
  expect(v2.x).toBeCloseTo(65.384);
  expect(v3.x).toBeCloseTo(51.538);
  expect(v4.x).toBeCloseTo(93.077);
  expect(v5.x).toBeCloseTo(162.308);
  expect(v0.width).toBeCloseTo(27.692);
  expect(timeline.findOverlaps(v0).length).toBe(0);
  expect(timeline.findOverlaps(v1).length).toBe(1);
  expect(timeline.findOverlaps(v2).length).toBe(2);
  expect(timeline.findOverlaps(v3).length).toBe(2);
  expect(timeline.findOverlaps(v4).length).toBe(2);
  expect(timeline.findOverlaps(v5).length).toBe(1);
  expect(timeline.findOverlaps(v1).map((o) => o.label)).toIncludeAllMembers(['v3']);
  expect(timeline.findOverlaps(v2).map((o) => o.label)).toIncludeAllMembers(['v3', 'v4']);
  expect(timeline.findOverlaps(v3).map((o) => o.label)).toIncludeAllMembers(['v1', 'v2']);
  expect(timeline.findOverlaps(v4).map((o) => o.label)).toIncludeAllMembers(['v2', 'v5']);
  expect(timeline.findOverlaps(v5).map((o) => o.label)).toIncludeAllMembers(['v4']);
  expect(v0.row).toBe(0);
  expect(v1.row).toBe(0);
  expect(v2.row).toBe(0);
  expect(v3.row).toBe(1);
  expect(v4.row).toBe(1);
  expect(v5.row).toBe(2);
  expect(v0.y).toBe(0);
  expect(v1.y).toBe(0);
  expect(v2.y).toBe(0);
  expect(v3.y).toBe(100);
  expect(v4.y).toBe(100);
  expect(v5.y).toBe(200);
  expect(timeline.minX).toBe(10);
  expect(timeline.maxX).toBeCloseTo(162.308);
  expect(timeline.minY).toBe(0);
  expect(timeline.maxY).toBe(200);
  expect(f.circularLinkType).toBe('bottom');
  expect(h.circularLinkType).toBe('top');
});

test('edge cases', () => {
  const timeline = new SankeyTimeline();
  expect(timeline.maxTime).toBe(0);
  expect(timeline.minTime).toBe(0);
  timeline.setRange([0, 100]);
  const zeroWidth = timeline.addNode('zeroWidth', 0, 0);
  expect(zeroWidth.width).toBe(1);
});
